# 递归

- 递归体
- 递归出口

## 递归体

递归体里面**传值**，我把它分为两种：1）递归函数的参数；2）返回值

### **一、递归函数的参数**

这里一般用于保留**层级**信息

对于根节点A的所有子节点`A.left`,`A.right`，它们所得到的参数都是A传进来的。

```java
public  void recur(TreeNode A,int layer){
    if(A==null) return;
    recur(A.left,layer+1);
    recur(A.right,layer+1);
}
```

- 这个参数值是**和父节点有关联**的某个值如`root.val`，层数。
- **一般情况**下：对于**同一根节点的两个节点**，它们获得的参数值是**一样**的.（当然在转向之前把参数值改了，比如layer+2，那么左右节点获取的值自然不一样）



### **二、返回值**

```java
public  int recur(TreeNode A){
    if(A==null) return 0;
    int left = recur(A.left);
    int right = recur(A.right);
    return Math.max(left,right) + 1;
}
```

- 返回值可以让**父节点**获得**和子节点相关联的值**

  

问题拆解的时候会大量使用到，比如判断两树是否相同，归并排序等等；

我们解释一下上述例子：

- 从**最左**的叶子节点**leaves**开始，其下的两空节点的返回值**left = r1，right = r2**由函数出口决定（此处是0）

- **r1和r2经过运算**，得到一个**返回值r3**，并传到**leaves的父节点**，作为父节点的left的结果。

这里给个建议，自顶向上去理解递归更便于写**递归的出口**以及**返回值的函数**。

## 递归出口

第一种是**必须**的：

出口条件：`root = null`

返回值：你可以看一下**最左叶子节点**，你希望该节点的**两个空节点**返回**给叶子节点**什么值



其他的是一些**可以提前终止**的情况：（其实这时候就叫做**回溯**了）

比如判断两树（p，q）是否相同，假如**只有一棵树为null**那么就能直接退出，返回false；

这里**只有一棵树为null**就是一个出口的条件，返回值是false。

# 示例

## 01背包问题：

向背包内装物品使得总价值最大，每件物品只允许装入一次。

### 问题分析

其实每件物品要么放进去要么没放进去，暴力的方式分析有2^n种可能性。

### 暴力解法：

写n个循环：

```java
for(int i = 0;i<2;i++){
    if(i==0){加入背包} else {不加入背包}
        
    for(int j=0;j<2;j++){
        if(j==0){加入背包} else {不加入背包}
        
        for(int k=0;j<2;j++){
            if(k==0){加入背包} else {不加入背包}
            //这时候已经知道ijk是否放进去背包，总价值就知道了
            //比较取不超重的最大的序列
        }
        
    }
}
```

上述方式显然格式一模一样，自己调用自己，我们能用递归来代替里面的循环

最后一层循环对应着递归的边界，也就是递归出口。

```java
public void res(int i){
    if(){}//判断是否超重，并和最大值比较
    for(int i = 0;i<2;i++){
        if(i==0){加入背包} else {不加入背包}
        res(j);
    }
}
```

### 递归优化

上面的解法问题太大了，三次还好，n次的话，2^n负担太重。

所以需要**找条件提早结束递归**。

比如：如果超重就不需要继续调用了。

```java
public void res(int i){
    if(){}//递归出口，判断是否超重，并和最大值比较
    for(int i = 0;i<2;i++){
        if(超重) {i=1;}//超重时提前结束
        if(i==0){加入背包} else {不加入背包}
        res(j);递归调用
    }
}
```

## 八皇后问题

惯例先写暴力破解情况

