# 目的

这里希望能解释一下在一个类的定义里面涉及的关键词包括**this，super，内部类，静态方法，构造函数**中涉及的相关知识点进行记录。

## 内部类

- **内部类可以访问外部类**的成员和函数
- **外部类**只可以创建**内部类的对象**来访问；

- 特别的，加入内部类为static所修饰。则只能访问外部类的**静态成员**
- 但静态类内部没有被static修饰的方法，还是可以使用this，这里的this指代的是内部类实例,参考建造者（Builder）模式

```java
public class Outer {
    static  int a1 = 0;
    int a = 0;
    public void o_func(){
        inner inner = new inner();
    }
    static class inner{
        public void i_func(){
            System.out.println(a1);
        }
    }
}
```

依次解释上面四条：

- `i_func`可以直接访问外部变量a1；而`o_func`却需要新建一个内部类对象

- `i_func`可以直接访问外部静态变量a1；而不能访问非静态变量a；因为inner是静态类，对于外部类Outer而言这是个静态的上下文。

  注意`i_func`是否被修饰为static，是相对于`inner`而言，访问`Outer`的时候还是看`Outer`是否是静态的。

- 

## this

### 如何理解this关键词；

先做一些准备工作：

1、定义了一个类

```java
public class Human{
    int age;
    int age1;
    //构造函数
    Human(int age){
        this.age = age;
        age1 = age;
    }
}
```

2、为了使用这个类，创建了几个实例

```
Human h1 = new Human();
Human h2 = new Human();
```

this的作用：

- this也是一个引用，**指向所创建的实例**；
- 成员变量age1和局部参数变量age不重名的时候是可以**不使用this**的；

这里给我们的感觉是this这个关键词可有可无，下面看下this的正确应用场合：

### Builder模式////

显然不使用this，你就需要在方法里面new一个对象再返回去。

```java
public class Human{
    int age;
    int age1;
    Human(){}//这个显然可以不写
    public Human human_age(int age){
    	age1 = age;
    	return this;
    }
}
```

### 调用其他构造函数

```java
public class Human{
    int age;
    int age1;
    Human(){
        this(age,)
    }//这个显然可以不写

}
```



## super

用于指代父类的一个**实例**，因此它能访问的都是些**非静态**的方法和成员。

## static

- 关于静态修饰符的误区，可以用类名.方法名来调用，**也可以通过实例.方法名来调**
- 静态方法没法**直接**访问非静态成员
- 非静态方法却可以直接访问静态/非静态成员

### 静态方法的可能需求

以main为例，我们可能有几种需求：

- 访问非静态成员，非静态函数,非静态内部类

  ```java
  int non_static_age;
  public void func1(int age){
  	this.non_static_age = age;
  }
  public class non_static_inner{
  
  }
  ```

- 访问静态成员，静态方法，静态内部类

  ```java
  static  int static_age = 0;
  public static void func2(int age){
      static_age = age;
  }
  public static class static_inner{
  
  }
  ```

#### 一、访问非静态对象

**通过创建一个外部类的实例，通过该实例来访问非静态对象**

注意内部类需要***new***一个实例出来才能使用，它不是外部类的简单成员。

```java
public static void main(String[] args) {
    static_test obj = new static_test();
    obj.func1(obj.non_static_age);//访问非静态成员和方法
    
    //访问非静态内部类
    non_static_inner nsi = obj.new non_static_inner(); 
}
```

#### 二、访问静态对象

可以直接访问不需要任何修饰符。

特别指出**this，super**这种关键词在静态方法里面是**用不了**的，毕竟它所指代的是一个**具体的实例**，这和静态方法的本质相悖。

```java
public static void main(String[] args) {
	func2(static_age);
    //类内部下面两种方法都可以，其实不需要限定外部类
    static_inner inner1 = new static_inner();
    static_inner inner2 = new static_test.static_inner();
}
```

## JVM加载顺序

JVM运行时各种函数的调用和执行顺序；

这里介绍了构造函数和静态代码块；其中构造函数部分解释了继承时的调用顺序。

[参考：构造函数详解](https://blog.csdn.net/qq_33642117/article/details/51909346)

## 构造函数

构造函数的作用：当new一个对象的时候，调用构造函数完成**对象的初始化**，完成一些成员变量赋初值之类的操作，所有类都有一个**默认的无参构造函数**。

特性：

- **没有返回值**
- 函数名和类名相同
- JVM会自动在创建对象的时候调用

你可以近似看成是满足上述几个特性的特殊的方法；

这篇文章的重点不是讲这个，而是介绍一下继承时父类和子类的构造函数的关系：

假设child继承了parent类；

child：

```java
public class child extends parent {
    public child(String s,Integer i){
        super(s);//如果没有这句话，就是默认调用父类无参构造函数
        System.out.println("子类构造函数");
    }
}
```

parent：

```java
public class parent {
    protected parent(String s ){
        System.out.println("父类构造函数");
    }
}
```

main：

```java
public static void main(String[] args) {
	child c1 = new child("1",2);
    //输出结果
    //父类构造函数
    //子类构造函数
}
```



明确几点：

- 父类没有写无参构造函数，且写了有参构造函数，那么就**有且仅有**这么一个**带参**构造函数了；
- 子类创建对象时，**会先调用父类的构造函数**，默认的构造函数是无参的，但是此时父类仅有一个有参的构造函数了，那么只能调用带一个String的构造函数；
- 子类很皮，写了一个参数和父类不太一样的构造函数（多了Integer），那么正常情况是会报错的，因为找不到参数一致的父类构造函数。所以需要加上`super(s)`，手动调用父类构造函数。

## 静态代码块

这个在JVM中运行的**运行优先级是最高**的，只要创建了一个类的实例，那么静态代码块的内容就会被调用。

看上去和构造函数有什么区别？把静态代码块的内容写在构造函数里面不也可以吗，为什么要多此一举再来个静态代码块？

因为构造函数可以重载，假如有个**需求**是**针对这个类**的，要求无论调用哪个构造函数创建实例，都得执行这个需求。当然可以在每个构造函数里面都把这个需求实现一遍，但显然造成代码重复，所以就需要静态代码块了。

**静态代码块是把构造函数里面的公共部分取出来构成的**

